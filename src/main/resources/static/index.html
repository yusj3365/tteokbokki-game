<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë–¡ë³¶ì´ ê²Œì„ (ë°•ìŠ¤ ëª¨ë“œ)</title>
    <style>
        :root {
            --cell-size: 40px;
            --board-rows: 10;
            --board-cols: 17;
            --primary-color: #ff4d4d;
            --bg-color: #fff5f5;
        }

        body {
            font-family: 'Pretendard', sans-serif;
            background-color: var(--bg-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }

        .header {
            display: flex;
            justify-content: space-between;
            width: calc(var(--cell-size) * var(--board-cols) + 10px);
            margin-bottom: 15px;
            padding: 10px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
            font-size: 1.1rem;
            font-weight: bold;
            z-index: 10;
        }

        .timer { color: #d32f2f; }
        .score { color: #1976d2; }

        .game-container {
            position: relative;
            background: #fff;
            padding: 5px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            touch-action: none;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(var(--board-cols), var(--cell-size));
            grid-template-rows: repeat(var(--board-rows), var(--cell-size));
            gap: 1px;
            background-color: #eee;
            border: 2px solid #333;
            position: relative; /* selection box ê¸°ì¤€ì  */
        }

        .cell {
            position: relative;
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: crosshair; /* ë°•ìŠ¤ ì„ íƒ ì»¤ì„œ */
            overflow: hidden;
        }

        /* ë¹ˆ ì…€ ìŠ¤íƒ€ì¼ */
        .cell[data-value="0"] {
            background-color: #f0f0f0;
            cursor: default;
        }

        /* ë–¡ë³¶ì´ ì¡°ê° ìŠ¤íƒ€ì¼ */
        .tteok-piece {
            position: absolute;
            width: 25%;
            height: 60%;
            background-color: white;
            border: 1px solid #f5c8c8;
            border-radius: 8px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
            pointer-events: none; /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ê°€ cellë¡œ ì „ë‹¬ë˜ë„ë¡ */
        }

        .cell-number {
            position: relative;
            z-index: 2;
            font-size: 18px;
            font-weight: 900;
            color: #d32f2f;
            text-shadow: 0 0 3px white, 0 0 3px white;
            pointer-events: none;
        }

        /* ë“œë˜ê·¸ ë°•ìŠ¤ (íŒŒë€ìƒ‰ ë°˜íˆ¬ëª…) */
        #selectionBox {
            position: absolute;
            border: 2px solid #2196f3;
            background-color: rgba(33, 150, 243, 0.3);
            display: none;
            pointer-events: none; /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í†µê³¼ */
            z-index: 100;
        }

        /* ì„ íƒëœ ì…€ í•˜ì´ë¼ì´íŠ¸ */
        .cell.selected {
            background-color: #bbdefb !important;
        }

        /* ê²°ê³¼ ëª¨ë‹¬ ë“± ê¸°ì¡´ ìŠ¤íƒ€ì¼ ìœ ì§€ */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        .modal {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
        }
        .bowl-container {
            position: relative;
            width: 200px;
            height: 100px;
            margin: 20px auto;
            background: radial-gradient(circle at 50% 30%, #d84315, #bf360c);
            border: 4px solid #5d4037;
            border-top: none;
            border-bottom-left-radius: 100px;
            border-bottom-right-radius: 100px;
            overflow: hidden;
        }
        .tteok-visual {
            position: absolute;
            width: 20px;
            height: 8px;
            background-color: white;
            border-radius: 4px;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .btn-restart {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 15px;
        }
    </style>
</head>
<body>

<div class="header">
    <div class="timer">â° <span id="timeDisplay">120</span>ì´ˆ</div>
    <div class="score">ğŸ˜‹ <span id="scoreDisplay">0</span>ì </div>
</div>

<div class="game-container">
    <div class="grid" id="grid">
        <!-- ë“œë˜ê·¸ ë°•ìŠ¤ ìš”ì†Œ -->
        <div id="selectionBox"></div>
    </div>
</div>

<div class="modal-overlay" id="resultModal">
    <div class="modal">
        <h2>ì˜ ë¨¹ì—ˆìŠµë‹ˆë‹¤!</h2>
        <p>ì´ íšë“ ì ìˆ˜: <strong id="finalScore" style="color: #d32f2f; font-size: 1.5rem;">0</strong>ì </p>
        <div class="bowl-container" id="bowl"></div>
        <button class="btn-restart" onclick="initGame()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
</div>

<script>
    // --- ê²Œì„ ì„¤ì • ---
    const ROWS = 10;
    const COLS = 17;
    const GAME_TIME = 120;

    // --- ìƒíƒœ ë³€ìˆ˜ ---
    let board = [];
    let score = 0;
    let timeLeft = GAME_TIME;
    let timerInterval = null;

    // ë°•ìŠ¤ ë“œë˜ê·¸ ê´€ë ¨ ë³€ìˆ˜
    let isDragging = false;
    let startPos = { r: -1, c: -1 }; // ê·¸ë¦¬ë“œ ì¢Œí‘œ
    let currentPos = { r: -1, c: -1 };

    // --- DOM ìš”ì†Œ ---
    const gridEl = document.getElementById('grid');
    const selectionBox = document.getElementById('selectionBox');
    const timeDisplay = document.getElementById('timeDisplay');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const resultModal = document.getElementById('resultModal');
    const finalScoreEl = document.getElementById('finalScore');
    const bowlEl = document.getElementById('bowl');

    // --- ì´ˆê¸°í™” ---
    function initGame() {
        score = 0;
        timeLeft = GAME_TIME;
        isDragging = false;
        resultModal.style.display = 'none';
        scoreDisplay.innerText = score;
        timeDisplay.innerText = timeLeft;

        // ë³´ë“œ ìƒì„± (1~9 ëœë¤)
        board = [];
        for (let r = 0; r < ROWS; r++) {
            let row = [];
            for (let c = 0; c < COLS; c++) {
                row.push(Math.floor(Math.random() * 9) + 1);
            }
            board.push(row);
        }

        renderBoard();
        startTimer();
    }

    function startTimer() {
        if (timerInterval) clearInterval(timerInterval);
        timerInterval = setInterval(() => {
            timeLeft--;
            timeDisplay.innerText = timeLeft;
            if (timeLeft <= 0) {
                endGame();
            }
        }, 1000);
    }

    function endGame() {
        clearInterval(timerInterval);
        finalScoreEl.innerText = score;
        renderBowl(score);
        resultModal.style.display = 'flex';
    }

    // --- ë Œë”ë§ ---
    function renderBoard() {
        // grid ë‚´ë¶€ì˜ cellë“¤ë§Œ ì§€ìš°ê³  selectionBoxëŠ” ìœ ì§€í•´ì•¼ í•¨
        // í•˜ì§€ë§Œ í¸ì˜ìƒ innerHTMLì„ ë°€ê³  selectionBoxë¥¼ ë‹¤ì‹œ ë¶™ì´ëŠ” ë°©ì‹ ì‚¬ìš©
        gridEl.innerHTML = '';
        gridEl.appendChild(selectionBox); // ë°•ìŠ¤ ìš”ì†Œ ë‹¤ì‹œ ì¶”ê°€

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.r = r;
                cell.dataset.c = c;

                const val = board[r][c];
                cell.dataset.value = val;

                if (val > 0) {
                    const numberEl = document.createElement('span');
                    numberEl.className = 'cell-number';
                    numberEl.innerText = val;
                    cell.appendChild(numberEl);

                    for (let i = 0; i < val; i++) {
                        const piece = document.createElement('div');
                        piece.className = 'tteok-piece';
                        piece.style.left = `${Math.random() * 50 + 10}%`;
                        piece.style.top = `${Math.random() * 20 + 10}%`;
                        piece.style.transform = `rotate(${Math.random() * 90 - 45}deg)`;
                        cell.appendChild(piece);
                    }
                }

                gridEl.appendChild(cell);
            }
        }
    }

    // --- ë°•ìŠ¤ ë“œë˜ê·¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ---

    // ë§ˆìš°ìŠ¤/í„°ì¹˜ ì‹œì‘
    function handleStart(e) {
        if (timeLeft <= 0) return;

        // ì´ë²¤íŠ¸ íƒ€ê²Ÿì´ cellì¸ì§€ í™•ì¸
        const target = e.target.closest('.cell');
        if (!target) return;

        e.preventDefault(); // í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€

        const r = parseInt(target.dataset.r);
        const c = parseInt(target.dataset.c);

        // ë¹ˆì¹¸ì—ì„œ ì‹œì‘í•´ë„ ë“œë˜ê·¸ëŠ” ê°€ëŠ¥í•˜ê²Œ í• ì§€, ì•„ë‹ˆë©´ ë§‰ì„ì§€?
        // ë³´í†µ ì‚¬ê³¼ê²Œì„ì€ ë¹ˆì¹¸ í¬í•¨í•´ì„œ ë“œë˜ê·¸ ê°€ëŠ¥í•˜ë¯€ë¡œ í—ˆìš©.

        isDragging = true;
        startPos = { r, c };
        currentPos = { r, c };

        updateSelectionVisual();
    }

    // ë§ˆìš°ìŠ¤/í„°ì¹˜ ì´ë™
    function handleMove(e) {
        if (!isDragging) return;

        let clientX, clientY;
        if (e.type === 'touchmove') {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        // í˜„ì¬ ì¢Œí‘œì— ìˆëŠ” ìš”ì†Œ ì°¾ê¸°
        const target = document.elementFromPoint(clientX, clientY);
        const cell = target ? target.closest('.cell') : null;

        if (cell) {
            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);

            // ì¢Œí‘œê°€ ë³€í–ˆì„ ë•Œë§Œ ì—…ë°ì´íŠ¸
            if (r !== currentPos.r || c !== currentPos.c) {
                currentPos = { r, c };
                updateSelectionVisual();
            }
        }
    }

    // ë§ˆìš°ìŠ¤/í„°ì¹˜ ì¢…ë£Œ
    function handleEnd() {
        if (!isDragging) return;
        isDragging = false;
        selectionBox.style.display = 'none';

        // ì„ íƒëœ ì˜ì—­ì˜ ë¡œì§ ê²€ì‚¬
        checkSelection();

        // ì‹œê°ì  ì„ íƒ í•´ì œ
        document.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
    gridEl.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);

    gridEl.addEventListener('touchstart', handleStart, {passive: false});
    window.addEventListener('touchmove', handleMove, {passive: false});
    window.addEventListener('touchend', handleEnd);


    // --- ë°•ìŠ¤ ì‹œê°í™” ë° ë°ì´í„° ê³„ì‚° ---
    function getSelectionBounds() {
        const minR = Math.min(startPos.r, currentPos.r);
        const maxR = Math.max(startPos.r, currentPos.r);
        const minC = Math.min(startPos.c, currentPos.c);
        const maxC = Math.max(startPos.c, currentPos.c);
        return { minR, maxR, minC, maxC };
    }

    function updateSelectionVisual() {
        const bounds = getSelectionBounds();

        // 1. ë°•ìŠ¤ ê·¸ë¦¬ê¸° (í”½ì…€ ë‹¨ìœ„ ê³„ì‚°)
        // ì‹œì‘ ì…€ê³¼ ë ì…€ì˜ DOM ìš”ì†Œë¥¼ ì°¾ì•„ ìœ„ì¹˜ ê³„ì‚°
        const startCell = getCellElement(bounds.minR, bounds.minC);
        const endCell = getCellElement(bounds.maxR, bounds.maxC);

        if (!startCell || !endCell) return;

        // gridEl ê¸°ì¤€ ìƒëŒ€ ì¢Œí‘œ ê³„ì‚°
        const gridRect = gridEl.getBoundingClientRect();
        const startRect = startCell.getBoundingClientRect();
        const endRect = endCell.getBoundingClientRect();

        const left = startRect.left - gridRect.left;
        const top = startRect.top - gridRect.top;
        const width = (endRect.right - gridRect.left) - left;
        const height = (endRect.bottom - gridRect.top) - top;

        selectionBox.style.left = `${left}px`;
        selectionBox.style.top = `${top}px`;
        selectionBox.style.width = `${width}px`;
        selectionBox.style.height = `${height}px`;
        selectionBox.style.display = 'block';

        // 2. í¬í•¨ëœ ì…€ í•˜ì´ë¼ì´íŠ¸
        document.querySelectorAll('.cell.selected').forEach(el => el.classList.remove('selected'));

        for (let r = bounds.minR; r <= bounds.maxR; r++) {
            for (let c = bounds.minC; c <= bounds.maxC; c++) {
                const cell = getCellElement(r, c);
                if (cell) cell.classList.add('selected');
            }
        }
    }

    function getCellElement(r, c) {
        // gridElì˜ ìì‹ ì¤‘ cell í´ë˜ìŠ¤ë¥¼ ê°€ì§„ ê²ƒë“¤ ì¤‘ ì¸ë±ìŠ¤ë¡œ ì°¾ê¸°
        // gridElì—ëŠ” selectionBoxê°€ í¬í•¨ë˜ì–´ ìˆìœ¼ë¯€ë¡œ querySelectorAll ì‚¬ìš©
        // r * COLS + c ë²ˆì§¸ cell
        const cells = gridEl.querySelectorAll('.cell');
        const index = r * COLS + c;
        return cells[index];
    }

    // --- ê²Œì„ ë¡œì§: ì—°ì†ëœ ìˆ«ì ê²€ì‚¬ ---
    function checkSelection() {
        const bounds = getSelectionBounds();
        let selectedValues = [];
        let selectedCoords = [];

        // 1. ì„ íƒëœ ì˜ì—­ì˜ ê°’ ìˆ˜ì§‘ (0 ì œì™¸)
        for (let r = bounds.minR; r <= bounds.maxR; r++) {
            for (let c = bounds.minC; c <= bounds.maxC; c++) {
                const val = board[r][c];
                if (val > 0) {
                    selectedValues.push(val);
                    selectedCoords.push({r, c});
                }
            }
        }

        // 2. ìœ íš¨ì„± ê²€ì‚¬
        // ì¡°ê±´: 2ê°œ ì´ìƒì´ì–´ì•¼ í•¨ (ë³´í†µ 1ê°œëŠ” ì—°ì†ì´ë¼ ì•ˆí•¨)
        if (selectedValues.length < 2) return;

        // ì •ë ¬
        selectedValues.sort((a, b) => a - b);

        // ì—°ì†ì„± ê²€ì‚¬
        let isConsecutive = true;
        for (let i = 0; i < selectedValues.length - 1; i++) {
            // í˜„ì¬ ê°’ + 1 ì´ ë‹¤ìŒ ê°’ê³¼ ê°™ì•„ì•¼ í•¨
            if (selectedValues[i] + 1 !== selectedValues[i+1]) {
                isConsecutive = false;
                break;
            }
        }

        // 3. ì„±ê³µ ì‹œ ì²˜ë¦¬
        if (isConsecutive) {
            popCells(selectedCoords);
        }
    }

    function popCells(coords) {
        score += coords.length;
        scoreDisplay.innerText = score;

        // ë³´ë“œì—ì„œ ì œê±° (0ìœ¼ë¡œ ë³€ê²½)
        coords.forEach(pos => {
            board[pos.r][pos.c] = 0;
        });

        // ì¤‘ë ¥ ì ìš©
        applyGravity();

        // í™”ë©´ ê°±ì‹ 
        renderBoard();
    }

    function applyGravity() {
        for (let c = 0; c < COLS; c++) {
            let newCol = [];
            // 0ì´ ì•„ë‹Œ ìˆ«ìë“¤ë§Œ ìˆ˜ì§‘
            for (let r = 0; r < ROWS; r++) {
                if (board[r][c] !== 0) {
                    newCol.push(board[r][c]);
                }
            }

            // [ìˆ˜ì •ë¨] ë¦¬í•„í•˜ì§€ ì•ŠìŒ!
            // ë¶€ì¡±í•œ ê°œìˆ˜ë§Œí¼ ìœ„ìª½ì„ 0ìœ¼ë¡œ ì±„ì›€
            const emptyCount = ROWS - newCol.length;
            for (let i = 0; i < emptyCount; i++) {
                newCol.unshift(0); // ëœë¤ ìˆ«ì ëŒ€ì‹  0 ì¶”ê°€
            }

            // ë³´ë“œì— ë°˜ì˜
            for (let r = 0; r < ROWS; r++) {
                board[r][c] = newCol[r];
            }
        }
    }

    function renderBowl(finalScore) {
        bowlEl.innerHTML = '';
        const visualCount = Math.min(finalScore, 100);
        for (let i = 0; i < visualCount; i++) {
            const item = document.createElement('div');
            item.className = 'tteok-visual';
            const left = Math.random() * 160 + 10;
            const top = Math.random() * 60 + 20;
            const rotate = Math.random() * 360;
            item.style.left = left + 'px';
            item.style.top = top + 'px';
            item.style.transform = `rotate(${rotate}deg)`;
            bowlEl.appendChild(item);
        }
    }

    // ì‹œì‘
    initGame();

</script>
</body>
</html>